âœ… ê·¸ë˜í”„ íƒìƒ‰ì´ë€?
ì •ì (Node)ê³¼ ê°„ì„ (Edge)ìœ¼ë¡œ ì´ë£¨ì–´ì§„ êµ¬ì¡°ì—ì„œ
ì›í•˜ëŠ” ë…¸ë“œë¥¼ ë°©ë¬¸ ìˆœì„œëŒ€ë¡œ íƒìƒ‰í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜

ğŸ” DFS (Depth-First Search)
íŠ¹ì§•
ê¹Šì´ ìš°ì„  íƒìƒ‰
ì¬ê·€, ìŠ¤íƒ ì‚¬ìš©
í•œ ë°©í–¥ ëê¹Œì§€ íŒŒê³ ë“¦
ëŒ€í‘œ ì½”ë“œ (ì¬ê·€)
void dfs(int node, boolean[] visited) {
    visited[node] = true;
    for (int next : graph[node]) {
        if (!visited[next]) {
            dfs(next, visited);
        }
    }
}


ğŸ” BFS (Breadth-First Search)
íŠ¹ì§•
ë„ˆë¹„ ìš°ì„  íƒìƒ‰
Queue ì‚¬ìš©
ì¸ì ‘í•œ ë…¸ë“œë¶€í„° ì°¨ë¡€ëŒ€ë¡œ
ëŒ€í‘œ ì½”ë“œ (í)
void bfs(int start, boolean[] visited) {
    Queue<Integer> queue = new LinkedList<>();
    queue.offer(start);
    visited[start] = true;
    while (!queue.isEmpty()) {
        int current = queue.poll();
        for (int next : graph[current]) {
            if (!visited[next]) {
                queue.offer(next);
                visited[next] = true;
            }
        }
    }
}


ğŸ¯ ì¸ì ‘ë¦¬ìŠ¤íŠ¸ ê¸°ë³¸ êµ¬ì¡° (ì •ìˆ˜ ê·¸ë˜í”„)
List<Integer>[] graph = new ArrayList[N+1];
for (int i = 0; i <= N; i++) graph[i] = new ArrayList<>();


âœ… DFS vs BFS ë¹„êµ
ë¹„êµ	DFS	BFS
ìë£Œêµ¬ì¡°	ìŠ¤íƒ (or ì¬ê·€)	í
ë°©ë¬¸ ìˆœì„œ	ê¹Šê²Œ â†’ ë°±íŠ¸ë˜í‚¹	ë„“ê²Œ, ê±°ë¦¬ìˆœ
íŠ¹ì§•	ê²½ë¡œ ì°¾ê¸°, ë°±íŠ¸ë˜í‚¹	ìµœë‹¨ê±°ë¦¬, ê±°ë¦¬ë³„ íƒìƒ‰
ëŒ€í‘œ ë¬¸ì œ	ë¯¸ë¡œ ê²½ë¡œ ì°¾ê¸°	ìµœì†Œ ì´ë™ íšŸìˆ˜

ğŸ¯ ì‹¤ì „ ë¬¸ì œ ì˜ˆê³ 
ì—°ê²° ìš”ì†Œì˜ ê°œìˆ˜ êµ¬í•˜ê¸° (DFS)
ìµœì†Œ ê±°ë¦¬ êµ¬í•˜ê¸° (BFS)
ë¯¸ë¡œ íƒˆì¶œ (BFS)
ì„¬ì˜ ê°œìˆ˜ (DFS + 2D ë°°ì—´)


