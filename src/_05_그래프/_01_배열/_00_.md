int[] dx = {1, 0, -1, 0};
int[] dy = {0, 1, 0, -1};

이건 단순한 배열 탐색이 아니라,
**"2차원 배열을 그래프로 생각하고 상하좌우를 탐색하는 알고리즘 패턴"**이야.

✅ 정리: 이건 그래프 탐색의 준비 운동이자 기초 응용 단계!
📌 이 패턴은 어디서 등장하냐면?
문제 유형	설명
미로 탐색	상하좌우로 이동하며 탈출 경로 찾기
섬의 개수	바다(0)와 육지(1)로 된 맵에서 연결된 땅 덩어리 세기
토마토 문제	익은 토마토가 상하좌우로 퍼지는 시간 측정
치즈 문제	외부 공기로 닿는 치즈가 사라지는 시뮬레이션
즉, 2차원 배열을 “그래프처럼” 순회하기 위한 기본 도구야.

int[] dx = {1, 0, -1, 0}; // 아래, 오른쪽, 위, 왼쪽
int[] dy = {0, 1, 0, -1};

for (int dir = 0; dir < 4; dir++) {
    int nx = x + dx[dir];
    int ny = y + dy[dir];
    // (nx, ny)를 다음 위치로 탐색
}
상하좌우 전체 방향 탐색 패턴



✅ 1. DFS vs BFS: 언제 쓰고 어떻게 구분할까?
구분 기준	DFS	BFS
구조	스택/재귀 기반	큐 기반
방식	한 방향으로 끝까지 파고듦 (깊게)	인접한 노드부터 넓게 탐색
주로 쓰이는 문제	연결된 블럭 탐색, 미로 탈출(경로 X), 백트래킹	최단거리, 감염/불/물 퍼짐, 단계별 변화
대표 키워드	연결 덩어리 세기	최소 이동 횟수 / 시간 순서 시뮬레이션
직관적 비유	미로에서 한 방향 끝까지 걸어감	미로에서 한 발자국씩 사방으로 확산
